function add(a: int64, b: int64) -> int64 {
    return a + b
}

type Ordered :: interface {
    function score(self) -> int64,
}

type Number implements Ordered :: struct {
    value: int64,
    function score(self) -> int64 {
        return self.value
    },
}

function identity[T](value: T) -> T {
    return value
}

function identityConstrained[T: Ordered](value: T) -> T {
    return value
}

function applyMapper(mapper: function(int64) -> int64, value: int64) -> int64 {
    return mapper(value)
}

function plusOne(value: int64) -> int64 {
    return value + 1
}

function run() -> int64 {
    result := add(1, 2)
    explicitGenericResult := identity[int64](result)
    inferredGenericResult := identity(result)
    constrainedResult := identityConstrained(Number { value: inferredGenericResult })
    mappedResult := applyMapper(plusOne, constrainedResult.score())
    print("ok")
    return mappedResult + explicitGenericResult
}
