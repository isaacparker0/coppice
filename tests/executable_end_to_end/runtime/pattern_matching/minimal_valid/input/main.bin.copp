type Direction :: enum {
    North,
    South,
}

function describe(value: int64 | string) -> string {
    return match value {
        int64 => "int"
        string => "string"
    }
}

function genericDescribe[T](value: T) -> string {
    return match value {
        T => "generic self"
    }
}

type Box[T] :: struct {
    value: T,
}

function genericApplicationMatches[T](value: T | Box[string]) -> boolean {
    return value matches T
}

function makeBox[T](value: T) -> Box[T] {
    return Box[T] { value: value }
}

function matchesGenericType[T](value: T | nil) -> boolean {
    return value matches T
}

function main() -> nil {
    print(describe(7))
    print(describe("ok"))

    probe: int64 | string := 7
    if probe matches int64 {
        print("is int64")
    }

    heading: Direction := Direction.North
    if heading matches Direction.North {
        print("north? yes")
    }
    label := match heading {
        Direction.North => "north"
        Direction.South => "south"
    }
    print(label)

    print(genericDescribe[int64](9))
    print(genericDescribe[string]("x"))
    print(genericDescribe(11))
    if genericApplicationMatches[Box[int64]](Box[int64] { value: 7 }) {
        print("generic app true")
    } else {
        print("generic app false")
    }
    if genericApplicationMatches[Box[int64]](Box[string] { value: "oops" }) {
        print("generic app true")
    } else {
        print("generic app false")
    }
    boxed := makeBox[int64](7)
    if matchesGenericType[Box[int64]](boxed) {
        print("reified generic true")
    } else {
        print("reified generic false")
    }

    return nil
}
