# https://bazelbuild.slack.com/archives/C05UNC5AANQ/p1771610074794149
# https://github.com/cerisier/toolchains_llvm_bootstrapped/pull/333

--- 3rd_party/macos_sdk/CLTools_macOSNMOS_SDK.BUILD.bazel
+++ 3rd_party/macos_sdk/CLTools_macOSNMOS_SDK.BUILD.bazel
@@ -5,3 +5,9 @@
     path = ".",
     visibility = ["//visibility:public"],
 )
+
+filegroup(
+    name = "sysroot_files",
+    srcs = glob(["**"]),
+    visibility = ["//visibility:public"],
+)

--- toolchain/BUILD.bazel
+++ toolchain/BUILD.bazel
@@ -329,6 +329,16 @@
     visibility = ["//visibility:public"],
 )
 
+alias(
+    name = "linker_wrapper",
+    actual = select({
+        "//platforms/config:macos_aarch64": "//tools/internal:linker-wrapper-macos-aarch64",
+        "//platforms/config:linux_x86_64": "//tools/internal:linker-wrapper-linux-x86_64",
+        "//platforms/config:linux_aarch64": "//tools/internal:linker-wrapper-linux-aarch64",
+    }),
+    visibility = ["//visibility:public"],
+)
+
 cc_action_type_set(
     name = "cpp_compile_actions_without_header_parsing",
     # See https://github.com/bazelbuild/rules_cc/blob/6dd2ef1fefbca004da449578c00d8ffb91a459ca/cc/toolchains/actions/BUILD#L224

--- tools/internal/BUILD.bazel
+++ tools/internal/BUILD.bazel
@@ -1,4 +1,9 @@
 load("@rules_cc//cc:cc_binary.bzl", "cc_binary")
+load("@rules_cc//cc:cc_library.bzl", "cc_library")
+load(
+    ":linker_contracts.bzl",
+    "linker_contract_from_cc_toolchain",
+)
 
 cc_binary(
     name = "header-parser",
@@ -11,3 +16,119 @@
     srcs = ["static_library_validator.cc"],
     visibility = ["//visibility:public"],
 )
+
+linker_contract_from_cc_toolchain(
+    name = "linker_contract",
+    out = "linker_contract.txt",
+)
+
+genrule(
+    name = "linker_wrapper_config",
+    outs = ["linker_wrapper_config.cc"],
+    cmd = "\n".join([
+        "cat > $@ <<'CONFIG'",
+        "#include \"tools/internal/linker_wrapper_config.h\"",
+        "",
+        "namespace llvm {",
+        "",
+        "const char* kLinkerWrapperClangRlocation = \"$(rlocationpath //tools:clang++)\";",
+        "const char* kLinkerWrapperContractRlocation = \"$(rlocationpath :linker_contract)\";",
+        "const char* kLinkerWrapperLibcxxSearchDirectoryRlocation = \"$(rlocationpath //runtimes/libcxx:libcxx_library_search_directory)\";",
+        "const char* kLinkerWrapperLibunwindSearchDirectoryRlocation = \"$(rlocationpath //runtimes/libunwind:libunwind_library_search_directory)\";",
+        "",
+        "}  // namespace llvm",
+        "CONFIG",
+    ]),
+    tools = [
+        "//runtimes/libcxx:libcxx_library_search_directory",
+        "//runtimes/libunwind:libunwind_library_search_directory",
+        "//tools:clang++",
+        ":linker_contract",
+    ],
+)
+
+cc_library(
+    name = "linker_wrapper_config_header",
+    hdrs = ["linker_wrapper_config.h"],
+    visibility = ["//visibility:private"],
+)
+
+cc_binary(
+    name = "linker-wrapper-macos-aarch64",
+    srcs = [
+        "linker_wrapper.cc",
+        ":linker_wrapper_config",
+    ],
+    data = [
+        "//runtimes:resource_directory",
+        "//runtimes/libcxx:libcxx_library_search_directory",
+        "//runtimes/libunwind:libunwind_library_search_directory",
+        "//tools:clang++",
+        "@macos_sdk//sysroot:sysroot_files",
+        "@compiler-rt//:clang_rt.builtins.static",
+        ":linker_contract",
+    ],
+    deps = [
+        ":linker_wrapper_config_header",
+        "@bazel_tools//tools/cpp/runfiles",
+    ],
+    target_compatible_with = [
+        "@platforms//os:macos",
+        "@platforms//cpu:aarch64",
+    ],
+    visibility = ["//visibility:public"],
+)
+
+cc_binary(
+    name = "linker-wrapper-linux-x86_64",
+    srcs = [
+        "linker_wrapper.cc",
+        ":linker_wrapper_config",
+    ],
+    data = [
+        "//runtimes:crt_objects_directory",
+        "//runtimes/libcxx:libcxx_library_search_directory",
+        "//runtimes/libunwind:libunwind_library_search_directory",
+        "//runtimes/glibc:glibc_library_search_directory",
+        "//runtimes:resource_directory",
+        "//tools:clang++",
+        "@compiler-rt//:clang_rt.builtins.static",
+        ":linker_contract",
+    ],
+    deps = [
+        ":linker_wrapper_config_header",
+        "@bazel_tools//tools/cpp/runfiles",
+    ],
+    target_compatible_with = [
+        "@platforms//os:linux",
+        "@platforms//cpu:x86_64",
+    ],
+    visibility = ["//visibility:public"],
+)
+
+cc_binary(
+    name = "linker-wrapper-linux-aarch64",
+    srcs = [
+        "linker_wrapper.cc",
+        ":linker_wrapper_config",
+    ],
+    data = [
+        "//runtimes:crt_objects_directory",
+        "//runtimes/libcxx:libcxx_library_search_directory",
+        "//runtimes/libunwind:libunwind_library_search_directory",
+        "//runtimes/glibc:glibc_library_search_directory",
+        "//runtimes:resource_directory",
+        "//tools:clang++",
+        "@compiler-rt//:clang_rt.builtins.static",
+        ":linker_contract",
+    ],
+    deps = [
+        ":linker_wrapper_config_header",
+        "@bazel_tools//tools/cpp/runfiles",
+    ],
+    target_compatible_with = [
+        "@platforms//os:linux",
+        "@platforms//cpu:aarch64",
+    ],
+    visibility = ["//visibility:public"],
+)

--- /dev/null
+++ tools/internal/linker_contracts.bzl
@@ -0,0 +1,95 @@
+load("@rules_cc//cc:action_names.bzl", "ACTION_NAMES")
+load("@rules_cc//cc:find_cc_toolchain.bzl", "find_cc_toolchain", "use_cc_toolchain")
+load("@rules_cc//cc/common:cc_common.bzl", "cc_common")
+
+def _stub_search_directory_name(path):
+    if path.endswith("/libcxx_library_search_directory"):
+        return "libcxx"
+    if path.endswith("/libunwind_library_search_directory"):
+        return "libunwind"
+    return None
+
+def _append_contract_lines(lines, argument):
+    if argument.startswith("-L") and len(argument) > 2:
+        stub_search_directory = _stub_search_directory_name(argument[2:])
+        if stub_search_directory != None:
+            lines.append("search_dir\t%s" % stub_search_directory)
+            return
+
+    lines.append("arg\t%s" % argument)
+
+def _linker_contract_from_cc_toolchain_impl(ctx):
+    cc_toolchain = find_cc_toolchain(ctx)
+    feature_configuration = cc_common.configure_features(
+        ctx = ctx,
+        cc_toolchain = cc_toolchain,
+        requested_features = ctx.features,
+        unsupported_features = ctx.disabled_features,
+    )
+
+    link_variables = cc_common.create_link_variables(
+        feature_configuration = feature_configuration,
+        cc_toolchain = cc_toolchain,
+        is_linking_dynamic_library = ctx.attr.is_linking_dynamic_library,
+        runtime_library_search_directories = [],
+        user_link_flags = ctx.attr.user_link_flags,
+    )
+    link_args = cc_common.get_memory_inefficient_command_line(
+        feature_configuration = feature_configuration,
+        action_name = ctx.attr.action_name,
+        variables = link_variables,
+    )
+
+    lines = [
+        "# directive<TAB>payload",
+    ]
+    pending_search_flag = False
+    for argument in link_args:
+        if not argument:
+            continue
+        if pending_search_flag:
+            pending_search_flag = False
+            stub_search_directory = _stub_search_directory_name(argument)
+            if stub_search_directory != None:
+                lines.append("search_dir\t%s" % stub_search_directory)
+                continue
+            lines.append("arg\t-L")
+            lines.append("arg\t%s" % argument)
+            continue
+
+        if argument == "-L":
+            pending_search_flag = True
+            continue
+
+        _append_contract_lines(lines, argument)
+
+    if pending_search_flag:
+        lines.append("arg\t-L")
+
+    ctx.actions.write(
+        output = ctx.outputs.out,
+        content = "\n".join(lines) + "\n",
+    )
+
+    return [DefaultInfo(files = depset([ctx.outputs.out]))]
+
+linker_contract_from_cc_toolchain = rule(
+    doc = "Generates a linker contract by expanding rules_cc link args for one link action.",
+    implementation = _linker_contract_from_cc_toolchain_impl,
+    attrs = {
+        "out": attr.output(
+            mandatory = True,
+        ),
+        "action_name": attr.string(
+            default = ACTION_NAMES.cpp_link_executable,
+        ),
+        "is_linking_dynamic_library": attr.bool(
+            default = False,
+        ),
+        "user_link_flags": attr.string_list(
+            default = [],
+        ),
+    },
+    fragments = ["cpp"],
+    toolchains = use_cc_toolchain(),
+)

--- /dev/null
+++ tools/internal/linker_wrapper.cc
@@ -0,0 +1,311 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <fstream>
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "tools/cpp/runfiles/runfiles.h"
+#include "tools/internal/linker_wrapper_config.h"
+
+using bazel::tools::cpp::runfiles::Runfiles;
+
+namespace {
+
+std::string ResolveRunfilePath(const Runfiles& runfiles,
+                               const char* runfile_key,
+                               const char* description) {
+  if (runfile_key == nullptr || runfile_key[0] == '\0') {
+    fprintf(stderr, "linker_wrapper: empty runfile key for %s\n", description);
+    exit(2);
+  }
+
+  std::string resolved_path = runfiles.Rlocation(runfile_key);
+  if (!resolved_path.empty()) {
+    return resolved_path;
+  }
+
+  fprintf(stderr, "linker_wrapper: failed to resolve runfile for %s: key='%s'\n",
+          description, runfile_key);
+  exit(2);
+}
+
+std::vector<std::string> ParseContractFields(const std::string& line) {
+  std::vector<std::string> fields;
+  size_t start = 0;
+
+  while (start <= line.size()) {
+    const size_t tab = line.find('\t', start);
+    if (tab == std::string::npos) {
+      fields.push_back(line.substr(start));
+      break;
+    }
+    fields.push_back(line.substr(start, tab - start));
+    start = tab + 1;
+  }
+  return fields;
+}
+
+std::string ResolveWorkspaceExecrootPath(const std::string& absolute_path) {
+  const std::string marker = "/execroot/";
+  const size_t marker_pos = absolute_path.find(marker);
+  if (marker_pos == std::string::npos) {
+    return "";
+  }
+
+  const size_t workspace_start = marker_pos + marker.size();
+  const size_t workspace_end = absolute_path.find('/', workspace_start);
+  if (workspace_end == std::string::npos) {
+    return "";
+  }
+  return absolute_path.substr(0, workspace_end);
+}
+
+std::string ResolveOutputBasePath(const std::string& absolute_path) {
+  const std::string marker = "/execroot/";
+  const size_t marker_pos = absolute_path.find(marker);
+  if (marker_pos != std::string::npos) {
+    return absolute_path.substr(0, marker_pos);
+  }
+
+  const std::string external_marker = "/external/";
+  const size_t external_pos = absolute_path.find(external_marker);
+  if (external_pos != std::string::npos) {
+    return absolute_path.substr(0, external_pos);
+  }
+  return "";
+}
+
+std::string ResolveRunfilesRootPath(const std::string& absolute_path) {
+  const std::string marker = ".runfiles/";
+  const size_t marker_pos = absolute_path.find(marker);
+  if (marker_pos == std::string::npos) {
+    return "";
+  }
+  return absolute_path.substr(0, marker_pos + marker.size() - 1);
+}
+
+bool PathExists(const std::string& path) {
+  return access(path.c_str(), F_OK) == 0;
+}
+
+std::string NormalizeRelativePath(const std::string& value,
+                                  const std::string& workspace_execroot,
+                                  const std::string& output_base,
+                                  const std::string& runfiles_root) {
+  if (value.empty() || value[0] == '/') {
+    return value;
+  }
+
+  const bool is_bazel_relative = value.rfind("bazel-out/", 0) == 0 ||
+                                 value.rfind("external/", 0) == 0;
+  if (is_bazel_relative) {
+    if (!workspace_execroot.empty()) {
+      const std::string candidate = workspace_execroot + "/" + value;
+      if (PathExists(candidate)) {
+        return candidate;
+      }
+    }
+
+    if (value.rfind("external/", 0) == 0 && !output_base.empty()) {
+      const std::string candidate = output_base + "/" + value;
+      if (PathExists(candidate)) {
+        return candidate;
+      }
+    }
+
+    if (!runfiles_root.empty()) {
+      const std::string candidate_in_main = runfiles_root + "/_main/" + value;
+      if (PathExists(candidate_in_main)) {
+        return candidate_in_main;
+      }
+
+      const std::string candidate_in_root = runfiles_root + "/" + value;
+      if (PathExists(candidate_in_root)) {
+        return candidate_in_root;
+      }
+
+      if (value.rfind("external/", 0) == 0) {
+        const std::string candidate_external_repo =
+            runfiles_root + "/" + value.substr(strlen("external/"));
+        if (PathExists(candidate_external_repo)) {
+          return candidate_external_repo;
+        }
+      }
+
+      const size_t external_segment = value.find("/external/");
+      if (external_segment != std::string::npos) {
+        const std::string candidate_external_from_bazel_out =
+            runfiles_root + "/" + value.substr(external_segment + strlen("/external/"));
+        if (PathExists(candidate_external_from_bazel_out)) {
+          return candidate_external_from_bazel_out;
+        }
+      }
+    }
+
+    fprintf(stderr,
+            "linker_wrapper: failed to resolve bazel-relative path '%s' (execroot='%s', output_base='%s', runfiles_root='%s')\n",
+            value.c_str(), workspace_execroot.c_str(), output_base.c_str(),
+            runfiles_root.c_str());
+    exit(2);
+  }
+
+  return value;
+}
+
+std::string NormalizePathLikeArgument(const std::string& argument,
+                                      const std::string& workspace_execroot,
+                                      const std::string& output_base,
+                                      const std::string& runfiles_root) {
+  if (argument.rfind("--sysroot=", 0) == 0) {
+    const std::string path = argument.substr(strlen("--sysroot="));
+    return std::string("--sysroot=") +
+           NormalizeRelativePath(path, workspace_execroot, output_base, runfiles_root);
+  }
+  if (argument.rfind("-L", 0) == 0 && argument.size() > 2) {
+    const std::string path = argument.substr(2);
+    return std::string("-L") +
+           NormalizeRelativePath(path, workspace_execroot, output_base, runfiles_root);
+  }
+  if (argument.rfind("-B", 0) == 0 && argument.size() > 2) {
+    const std::string path = argument.substr(2);
+    return std::string("-B") +
+           NormalizeRelativePath(path, workspace_execroot, output_base, runfiles_root);
+  }
+  return NormalizeRelativePath(argument, workspace_execroot, output_base,
+                               runfiles_root);
+}
+
+void RequireArity(const std::vector<std::string>& fields, size_t expected,
+                  const char* directive) {
+  if (fields.size() == expected) {
+    return;
+  }
+  fprintf(stderr,
+          "linker_wrapper: invalid contract %s directive (expected %zu fields, got %zu)\n",
+          directive, expected, fields.size());
+  exit(2);
+}
+
+void ApplyContractLine(const std::vector<std::string>& fields,
+                       const std::string& workspace_execroot,
+                       const std::string& output_base,
+                       const std::string& runfiles_root,
+                       const Runfiles& runfiles,
+                       std::vector<std::string>* arguments) {
+  if (fields.empty()) {
+    return;
+  }
+
+  if (fields[0] == "arg") {
+    RequireArity(fields, 2, "arg");
+    arguments->push_back(NormalizePathLikeArgument(
+        fields[1], workspace_execroot, output_base, runfiles_root));
+    return;
+  }
+
+  if (fields[0] == "search_dir") {
+    RequireArity(fields, 2, "search_dir");
+    const char* runfile_key = nullptr;
+    const char* description = nullptr;
+    if (fields[1] == "libcxx") {
+      runfile_key = llvm::kLinkerWrapperLibcxxSearchDirectoryRlocation;
+      description = "libcxx search directory";
+    } else if (fields[1] == "libunwind") {
+      runfile_key = llvm::kLinkerWrapperLibunwindSearchDirectoryRlocation;
+      description = "libunwind search directory";
+    } else {
+      fprintf(stderr, "linker_wrapper: unknown search_dir value '%s'\n",
+              fields[1].c_str());
+      exit(2);
+    }
+
+    arguments->push_back(std::string("-L") +
+                         ResolveRunfilePath(runfiles, runfile_key, description));
+    return;
+  }
+
+  fprintf(stderr, "linker_wrapper: unknown contract directive '%s'\n",
+          fields[0].c_str());
+  exit(2);
+}
+
+void AppendLinkerContractArguments(const std::string& contract_path,
+                                   const std::string& workspace_execroot,
+                                   const std::string& output_base,
+                                   const std::string& runfiles_root,
+                                   const Runfiles& runfiles,
+                                   std::vector<std::string>* arguments) {
+  std::ifstream contract_stream(contract_path);
+  if (!contract_stream.is_open()) {
+    fprintf(stderr, "linker_wrapper: failed to open linker contract at '%s'\n",
+            contract_path.c_str());
+    exit(2);
+  }
+
+  std::string line;
+  while (std::getline(contract_stream, line)) {
+    if (line.empty() || line[0] == '#') {
+      continue;
+    }
+    ApplyContractLine(ParseContractFields(line), workspace_execroot, output_base,
+                      runfiles_root, runfiles, arguments);
+  }
+}
+
+}  // namespace
+
+int main(int argc, char** argv) {
+  if (argc < 2) {
+    fprintf(stderr, "Usage: %s <clang++-style-link-args...>\n"
+                    "Example: %s input.o -o output_binary\n",
+            argv[0], argv[0]);
+    return 2;
+  }
+
+  std::string runfiles_error;
+  std::unique_ptr<Runfiles> runfiles(
+      Runfiles::Create(argv[0], BAZEL_CURRENT_REPOSITORY, &runfiles_error));
+  if (!runfiles) {
+    fprintf(stderr, "linker_wrapper: failed to initialize runfiles: %s\n",
+            runfiles_error.c_str());
+    return 2;
+  }
+
+  const std::string clang_path =
+      ResolveRunfilePath(*runfiles, llvm::kLinkerWrapperClangRlocation,
+                         "platform clang++");
+  const std::string contract_path = ResolveRunfilePath(
+      *runfiles, llvm::kLinkerWrapperContractRlocation,
+      "linker contract");
+  const std::string workspace_execroot =
+      ResolveWorkspaceExecrootPath(contract_path);
+  const std::string output_base = ResolveOutputBasePath(contract_path);
+  const std::string runfiles_root = ResolveRunfilesRootPath(contract_path);
+
+  std::vector<std::string> argument_storage;
+  argument_storage.reserve(static_cast<size_t>(argc) + 24);
+  argument_storage.push_back(clang_path);
+
+  AppendLinkerContractArguments(contract_path, workspace_execroot, output_base,
+                                runfiles_root, *runfiles, &argument_storage);
+
+  for (int index = 1; index < argc; ++index) {
+    argument_storage.push_back(argv[index]);
+  }
+
+  std::vector<char*> exec_arguments;
+  exec_arguments.reserve(argument_storage.size() + 1);
+  for (std::string& argument : argument_storage) {
+    exec_arguments.push_back(const_cast<char*>(argument.c_str()));
+  }
+  exec_arguments.push_back(nullptr);
+
+  execv(clang_path.c_str(), exec_arguments.data());
+  fprintf(stderr, "linker_wrapper: execv failed for '%s': %s\n",
+          clang_path.c_str(), strerror(errno));
+  return 2;
+}

--- /dev/null
+++ tools/internal/linker_wrapper_config.h
@@ -0,0 +1,10 @@
+#pragma once
+
+namespace llvm {
+
+extern const char* kLinkerWrapperClangRlocation;
+extern const char* kLinkerWrapperContractRlocation;
+extern const char* kLinkerWrapperLibcxxSearchDirectoryRlocation;
+extern const char* kLinkerWrapperLibunwindSearchDirectoryRlocation;
+
+}  // namespace llvm
